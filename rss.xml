<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Keruspe's blag - RSS feed</title>
        <link>http://www.imagination-land.org</link>
        <description><![CDATA[Various free software hacking stuff]]></description>
        <atom:link href="http://www.imagination-land.org/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Wed, 21 Nov 2012 00:00:00 UT</lastBuildDate>
        <item>
    <title>Home sweet home</title>
    <link>http://www.imagination-land.org/posts/2012-11-21-home-sweet-home.html</link>
    <description><![CDATA[<article>
    <header>
        <h1>Home sweet home</h1>
        <p>by <em>Marc-Antoine Perennou</em> on <strong>November 21, 2012</strong></p>
        <p>Tagged as: <a href="/tags/misc.html">misc</a>.</p>
    </header>

    <section>
        <h2 id="welcome">Welcome</h2>
<p>It has been a long time since I first wanted to get a blog.</p>
<p>I’ll mostly speak here about free software and stuff I like to hack, from sysadmin to development and debugging. I write code mostly in Java for my job, but my language of choice is the C for my personal projects. This is why this blog is written in haskell.</p>
<p>Just to be clear, what I mean by sysadmin is not</p>
<pre><code>sudo apt-get install kde</code></pre>
<p>I’m a source-based distributions enthusiast and prefer tutorials and tips about raw software over distro-specific ones.</p>
<h2 id="special-thanks">Special thanks</h2>
<p>This blog is powered by <a href="http://jaspervdj.be/hakyll/index.html">Hakyll</a>.</p>
<p>It was written by <a href="https://clementd.cleverapps.io/posts/2012-10-21-blog-deployment-system.html">Clément Delafargue</a> and I shamelessly stole it from him.</p>
<p>This blog is available as <a href="http://github.com/Keruspe/blog">a git repository</a> and hosted on <a href="http://clever-cloud.com">The Clever Cloud</a> which is the company I work for.</p>
    </section>
</article>
]]></description>
    <pubDate>Wed, 21 Nov 2012 00:00:00 UT</pubDate>
    <guid>http://www.imagination-land.org/posts/2012-11-21-home-sweet-home.html</guid>
</item>
<item>
    <title>Knowing your system - Part 1 - Basis on UNIX-like systems</title>
    <link>http://www.imagination-land.org/posts/2012-11-22-knowing-your-system-part-basics-on-unixlike-systems.html</link>
    <description><![CDATA[<article>
    <header>
        <h1>Knowing your system - Part 1 - Basis on UNIX-like systems</h1>
        <p>by <em>Marc-Antoine Perennou</em> on <strong>November 22, 2012</strong></p>
        <p>Tagged as: <a href="/tags/gnu.html">gnu</a>, <a href="/tags/unix.html">unix</a>, <a href="/tags/linux.html">linux</a>, <a href="/tags/sysadmin.html">sysadmin</a>, <a href="/tags/knowingyoursystem.html">knowingyoursystem</a>.</p>
    </header>

    <section>
        <p>Before starting to blog about more technical stuff, I’d like to remember a few basis about UNIX-like systems.</p>
<p>I use a GNU/Linux based distribution most of the time, so I’ll speak about this kind of system, but most of it is true for any UNIX-like system such as the BSDs and Mac OS X.</p>
<h2 id="what-is-gnulinux">What is GNU/Linux ?</h2>
<p>First of all, let’s make things clear: I’m talking about “GNU/Linux”, not Linux. What is the difference? Linux is “only” a kernel, the heart of your system. Linux is the piece of your OS which will provide you several interfaces to interact with the hardware and to manage your processes. GNU is a set of libraries (a set of utilities for a developer) and tools such as the well known glibc, gcc, tar and sed. GNU is used most of the time on top of Linux, but can be used on top of other kernels, like Debian shown us with <a href="http://www.debian.org/ports/kfreebsd-gnu/">its GNU/kFreeBSD version</a>.</p>
<p>GNU/Linux is not a full system, it’s only the kernel with only a few set of core components on top of it. This set can be <em>distributed</em> in several different ways, with different team managing them: the GNU/Linux distributions. The most common desktop distributions are:</p>
<ul>
<li><a href="http://www.debian.org/">Debian GNU/Linux</a></li>
<li><a href="http://www.ubuntu.com/">Ubuntu GNU/Linux</a> (Which is Debian-based)</li>
<li><a href="http://fedoraproject.org/">Fedora GNU/Linux</a></li>
</ul>
<h2 id="its-better-with-colors">It’s better with colors</h2>
<p>These distribution provide the GNU/Linux set packaged with a bunch of other software, like a graphical environment (aka desktop/window manager). The most common desktop managers are:</p>
<ul>
<li><a href="http://www.gnome.org/">GNOME</a></li>
<li><a href="http://www.kde.org/">KDE</a></li>
<li><a href="http://xfce.org/">XFCE</a></li>
</ul>
<p>But there are also another kind of desktop managers which become more and more popular, like:</p>
<ul>
<li><a href="http://xmonad.org/">xmonad</a></li>
<li><a href="http://i3wm.org/">i3</a></li>
<li><a href="http://awesome.naquadah.org/">awesome</a></li>
</ul>
<p>They all run on top of a graphical server which aim is to display what we ask it to: <a href="http://www.x.org/">X11</a>. A new compositor (a part of a graphical server) is raising: <a href="http://wayland.freedesktop.org/">wayland</a>. Wayland will allow application to be a lot more flexible and will improve performances, but it will be lazier (applications will have to do more stuff by themselves).</p>
<p>The X.org server, wayland, and all related libraries and tools are part of <a href="http://www.freedesktop.org/">the freedesktop project</a>. Freedesktop aims to provide a free and opensource grapical user experience to everyone.</p>
<h2 id="a-gnulinux-system-structure.">A GNU/Linux system structure.</h2>
<p>On a UNIX-like system, everything is a file. A folder is just a specific kind of file, which can contain some other files. Each piece of harware stuff is seen as a file. You write and read this file to interact with the real hardware. All of these files are stored in a tree respecting the <a href="http://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard">Filesystem Hierarchy Standard</a>.</p>
<ul>
<li>/ is the parent folder of everything, we call it “slash”.</li>
<li>/boot is the folder where everything needed by the bootloader (The menu where you select which OS to start) is stored.</li>
<li>/dev contains all the files corresponding to hardware devices or core functionnalities.</li>
<li>/etc contains all the system-wide configuration files.</li>
<li>/home contains the personnal directories of the users.</li>
<li>/media used to be the place where external storage devices used to be automounted (the place where we accessed their files).</li>
<li>/mnt is the place where we explicitely mount external (or internal) storage devices.</li>
<li>/opt is the place where we place software we install system-wide using automatic installers</li>
<li>/proc contains data specific to currently running processes</li>
<li>/root is the home directory of “root” (administrator)</li>
<li>/tmp is the place where are stored temporary data</li>
<li>/var is the place where will be stored variable content such as logs and databases content</li>
<li>/run is the folder used by software to store runtime specific data</li>
<li>/run/media is the replacement to the deprecated /media</li>
<li>/lib is the place where are stored libraries (there also can be /lib32 and/or /lib64)</li>
<li>/bin is the place where the executables are stored</li>
<li>/sbin is the place where administrative executables are stored</li>
<li>/usr (unix shared resources) is a legacy directory where we used to put all the binaries, libraries and data which were not necessary to boot the system, when the main hard drive was too small to store everything. It’s now becoming the standard place in which are moved /bin, /sbin and /lib.</li>
</ul>
<p>There is now a standard filesystem hierarchy for data stored in each user home directory, guided by freedesktop: <a href="http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html">The XDG base directory specification</a>.</p>
<h2 id="the-gnulinux-boot-process">The GNU/Linux boot process</h2>
<p>When you start your computer, you (usually) get to a bootloader. This bootloader asks you to select which system you want to start. What you actually do when you select an entry is to select a couple of informations:</p>
<ul>
<li>A kernel (you can have several ones installed at the same time, but you only boot using one of them).</li>
<li>The part of your hard drive where your system lays.</li>
<li>Extra configuration for your kernel.</li>
</ul>
<p>When your kernel has successfully initialized everything, it then gives the power to a root process, commonly called “init”, which goal is to track all the other processes that you and your system will run. The init process will then reach a few breakpoints (which can be called runlevels, or targets). To each of these breakpoints correspond a list of process that must be started. This is how all the root components of your system are started in the right order. One of the last things to start is the graphical interface.</p>
    </section>
</article>
]]></description>
    <pubDate>Thu, 22 Nov 2012 00:00:00 UT</pubDate>
    <guid>http://www.imagination-land.org/posts/2012-11-22-knowing-your-system-part-basics-on-unixlike-systems.html</guid>
</item>
<item>
    <title>Knowing your system - Part 2 - The init process</title>
    <link>http://www.imagination-land.org/posts/2012-11-29-knowing-your-system-part-the-init-process.html</link>
    <description><![CDATA[<article>
    <header>
        <h1>Knowing your system - Part 2 - The init process</h1>
        <p>by <em>Marc-Antoine Perennou</em> on <strong>November 29, 2012</strong></p>
        <p>Tagged as: <a href="/tags/gnu.html">gnu</a>, <a href="/tags/unix.html">unix</a>, <a href="/tags/linux.html">linux</a>, <a href="/tags/sysadmin.html">sysadmin</a>, <a href="/tags/knowingyoursystem.html">knowingyoursystem</a>.</p>
    </header>

    <section>
        <p><a href="http://www.imagination-land.org/posts/2012-11-22-knowing-your-system-part-basics-on-unixlike-systems.html">As we last saw</a>, when we start an UNIX-like system, the kernel gives the hand to a main process called “init”. We’ll now see how it works.</p>
<h2 id="the-goal-of-the-init-process">The goal of the init process</h2>
<p>The init process is the more inportant software running on your system. It’s goal is to start everything up as it has to be for your system to work properly. It will manage everything, report errors (and maybe act regarding them) and supervise everything. When a process will get orphaned (because its father process, the one which started it, exits or dies), init will automatically become its father process.</p>
<p>The init process allows you to get a trace of what your processes and doing, where they do come from, and wether they’re in a decent or a zombie state.</p>
<h2 id="the-legacy-system-v-init">The legacy System V init</h2>
<p>UNIX System V is probably the most known UNIX system. It was one of the most used operating systems in the 80s-90s for servers. Its init system is the base of most of our actual systems’ ones.</p>
<p><a href="http://savannah.nongnu.org/projects/sysvinit">SysVInit</a> design splitted the boot process into several step (usually 6 or 7 for recent versions) called “runlevels”: - the runlevel 0 corresponds to the system shutdown - the runlevel 1 corresponds to the “single user” mode, it’s the step when the system’s basic components are started - the runlevel 2 corresponds to the “multi user” mode, all things that do not require networking are started there - the runlevel 3 corresponds to the “multi user with network” mode, all things requiring networking are started there - the runlevel 4 is usually unused, you can use it for specific custom purpose - the runlevel 5 usually starts the graphical user interface, but a lot of distributions already does it in runlevel 3 - the runlevel 6 is used to reboot the system</p>
<p>Services that need to be started when you start the system must provide what is called an “init script” which will tell SysVInit how to start the said service. This is usually a bash script which takes as argument either start, stop or restart. If none is provided by upstream, you still can write your own one. You then assign these services to some runlevels, and they will be started in a random order when SysVInit will reach this runlevel. Usually they are started in alphabetical order so you can specify the order you want by prefixing the init scripts with a numerical value such as “03” or “99” so start in n early or late stage of this runlevel. Everything is done one after another, each task waits for the previous one to finish before starting.</p>
<p>In /etc/inittab, you specify which runlevel you want to reach by default at startup, so you can tell it to stop at runlevel 3 for example. You will be able later to run “init 5” to start everything for example. You also can run “init 6” which is equivalent to “reboot” or “init 0” which is equivalent to “shutdown now”</p>
<h2 id="the-new-generation-init-systems">The new generation init systems</h2>
<p>Here are four examples of alternatives to SysVInit. There are other but these are the most used.</p>
<h3 id="openrc">OpenRC</h3>
<p><a href="http://www.gentoo.org/proj/en/base/openrc/">OpenRC</a> is <a href="http://www.gentoo.org/">Gentoo</a>’s init process. It is not a standalone one as it relies on SysVInit, it’s only there to add handy features and preformance to SysVInit.</p>
<p>OpenRC allows you to explicitely specify dependencies between services, which makes the task a lot easier than having to prepend numbers to services names. It also adds the ability to get configuration files separated from init scripts.</p>
<h3 id="runit">Runit</h3>
<p><a href="http://smarden.org/runit/">Runit</a> is a replacement to SysVInit that also handles runlevels. It is not compatible with the legacy ones, though. Runit splits the init process into three runlevels named “stages”: - the stage 1 corresponds to the system initialization. If anything goes wrong here, runit drops you to a rescue shell. - the stage 2 corresponds to everything that needs to be started (like SysVInit’s runlevel 5) - the stage 3 corresponds to shutdown tasks.</p>
<p>Runit can read and handle SysVInit runlevels through an external compatibility layer called runsvdir but this is not how it is intended to be ran.</p>
<p>Runit’s goal is to be as small and light as possible, it does exactly what you ask it to, and nothing more. You end up with a system as small as possible, but you do not have to forget anything since it won’t automatically do it for you.</p>
<h3 id="upstart">Upstart</h3>
<p><a href="http://upstart.ubuntu.com/">Upstart</a> is an <a href="http://www.ubuntu.com/">Ubuntu</a> attempt to make th system boot faster. It is fully evenemential and hence only waits for stuff that needs to be waited for when it starts every process needed by the system. It allows to start all these processes in parallel making them wait for dependencies only once they need them. When a process fails or crashes, Upstart can handle this event to restart it automatically.</p>
<p>Upstart is fully compatible with SysVInit and the transition should be smooth and quite easy. Some software may need specific init scripts though, especially to take advantage of upstart features.</p>
<h3 id="systemd">systemd</h3>
<p><a href="http://www.freedesktop.org/wiki/Software/systemd">systemd</a> (yes, no caps here) is <a href="http://www.redhat.com/">Red Hat</a>’s attempt to make the boot faster, especially for its desktop distribution: <a href="http://fedoraproject.org/">Fedora</a>. systemd is widely inspired from Upstart, the Upstart’s TODO list, and from Apple’s Mac OS X init system: launchd.</p>
<p>systemd is as lazy as possible. It does not handle “runlevels” but rather “targets”. Everything hadnled by systemd is called a “unit”. A unit can either be a “target” (runlevel equivalent) or a “service” (the software itself), a “socket”, a “mount” operation, an “automount” operation or even a “timer” (cron-like) which will run your service in a regular fashion.</p>
<p>Some targets are provided by default by you can create your own ones as you wish, with the names you want. You can specify which target has to be reached by default at system startup. In each unit, you can specify before or after which unit it should be started, whether it requires or is required by other units, if it conflicts with other units, and to which target it belongs. This allows systemd to know which targets and services it should start before starting the defuault target specified. To eash target corresponds a target.wants directory, where the unit which should be started with this target are symbolic-linked. The sockets and mount operations are kinda more specific. Mount and automount operations are autogenerated from /etc/fstab (automounting means that the filesystem appears to be mounted, but it really is mounted only once it has been accessed, which leads to a consequent gain of time). If a socket unit corresponds to a service one, systemd supports the socket activation of this service, which means that the service will really be started only when another service starts to communicate with it.</p>
<p>systemd is a real source of conflict between people against it and people in favor of it. The main argument of people which are against it is that is does too many things, it’s too complex and ships too many functionnalities. I think this is a fake problem, since most of the functionnalities are optional (and thus can be disabled), and everything is split into several binaries (systemd doesn’t do all this stuff itself but calls tools that it ships to do so). It is fully modular, and not modular like its “oponents”.</p>
<p>One of the interresting tools provided by systemd is the “journal”. The journal is basically a logging utility directly integrated in the init process (well, it actually only communicates with it, it’s not <em>really</em> in it). This allows you to get rid of an external logging utility such as syslog-ng or rsyslog. You can browse all the logs with the “journalctl” command which allows you to apply a lot of filters on them.</p>
<p>A really interresting serie of blog post by Lennart Poettering (systemd’s lead developer) is available <a href="http://www.freedesktop.org/wiki/Software/systemd">here</a>.</p>
    </section>
</article>
]]></description>
    <pubDate>Thu, 29 Nov 2012 00:00:00 UT</pubDate>
    <guid>http://www.imagination-land.org/posts/2012-11-29-knowing-your-system-part-the-init-process.html</guid>
</item>

    </channel> 
</rss>
